/*
The sequence of triangle numbers is generated by adding 
the natural numbers. So the 7th triangle number would be
 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have 
over five divisors.

What is the value of the first triangle number to have 
over five hundred divisors?

THOUGHTS
- can calculate next number with last two numbers by 
  adding their difference + 1 to the last number
- what is most efficient way to count divisors? maybe formula.
- brute force factorization costs sqrt(n) for each digit n, so
  multiply that by estimated number of triangle numbers calculated.
  Maybe 1M? Which would be 1B ops worst case, so feasible.
  (turns out it's 76M)
*/
// First value generated is 3rd triangle number
function* generateSequence() {
  let previousTriangleNumber = 1;
  let currentTriangleNumber = 3;
  while (true) {
    const difference = currentTriangleNumber - previousTriangleNumber;
    previousTriangleNumber = currentTriangleNumber;
    currentTriangleNumber = currentTriangleNumber + difference + 1;
    yield currentTriangleNumber;
  }
}

function countFactors(n) {
  const factors = [];
  const squareRoot = Math.sqrt(n);
  for (let i = 1; i < Math.floor(squareRoot); i++) {
    if (n % i === 0) {
      factors.push(i);
    }
  }

  // Didn't include perfect square root earlier, so counting after doubling
  let count = factors.length * 2;
  if (Number.isInteger(squareRoot)) {
    count++;
  }

  return count;
}

function divisibleTriangleNumber() {
  const triangleNumberIterator = generateSequence();
  let triangleNumber;
  while (true) {
    triangleNumber = triangleNumberIterator.next().value;
    const factorCount = countFactors(triangleNumber);
    if (factorCount > 500) {
      return triangleNumber;
    }
  }
}

console.log(divisibleTriangleNumber());
